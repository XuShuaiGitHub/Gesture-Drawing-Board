<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>é«˜çº§æ‰‹åŠ¿ç»˜ç”»æ¿ - æµç•…è½¨è¿¹ä¼˜åŒ–ç‰ˆ</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
      rel="stylesheet" />
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Roboto", sans-serif;
      }

      body {
        background: linear-gradient(135deg, #1a2a6c, #2c3e50, #1a2a6c);
        color: #fff;
        min-height: 100vh;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        overflow-x: hidden;
      }

      header {
        text-align: center;
        padding: 20px 0;
        width: 100%;
        max-width: 1000px;
        margin: 0 auto 20px;
      }

      h1 {
        font-size: 2.8rem;
        margin-bottom: 10px;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        background: linear-gradient(to right, #ff7e5f, #feb47b);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .subtitle {
        font-size: 1.3rem;
        opacity: 0.9;
        margin-top: 10px;
        color: #e0e0e0;
      }

      .container {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        max-width: 1200px;
        gap: 30px;
      }

      .camera-container {
        width: 100%;
        max-width: 800px;
        background: rgba(25, 25, 35, 0.85);
        border-radius: 20px;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
        padding: 25px;
        display: flex;
        flex-direction: column;
      }

      .camera-header {
        text-align: center;
        margin-bottom: 20px;
      }

      .camera-header h2 {
        font-size: 1.8rem;
        color: #4facfe;
        margin-bottom: 10px;
      }

      .camera-view {
        position: relative;
        width: 100%;
        height: 350px;
        background: #000;
        border-radius: 15px;
        overflow: hidden;
        margin-bottom: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .camera-view video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1); /* ä¿®å¤è§†é¢‘é•œåƒé—®é¢˜ */
      }

      #cameraPlaceholder {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
      }

      .gesture-output {
        background: rgba(20, 20, 30, 0.9);
        border-radius: 15px;
        padding: 20px;
        text-align: center;
        font-size: 1.3rem;
        min-height: 100px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.4);
        border: 1px solid #4facfe;
      }

      .gesture-name {
        font-size: 1.8rem;
        font-weight: bold;
        color: #feb47b;
        margin-bottom: 10px;
      }

      .gesture-desc {
        color: #a0a0c0;
        font-size: 1.1rem;
      }

      .controls {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 15px;
        margin-top: 20px;
      }

      .control-btn {
        background: linear-gradient(to right, #4facfe, #00f2fe);
        color: white;
        border: none;
        border-radius: 50px;
        padding: 14px 25px;
        font-size: 1.1rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .control-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
      }

      .control-btn:active {
        transform: translateY(1px);
      }

      .mode-indicator {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 20px;
        border-radius: 50px;
        background: rgba(79, 172, 254, 0.3);
        font-size: 1.1rem;
      }

      .canvas-container {
        background: rgba(25, 25, 35, 0.85);
        border-radius: 20px;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
        padding: 25px;
        width: 100%;
        max-width: 1000px;
        margin-top: 10px;
      }

      .canvas-header {
        text-align: center;
        margin-bottom: 20px;
      }

      .canvas-header h2 {
        font-size: 1.8rem;
        color: #00f2fe;
        margin-bottom: 10px;
      }

      #drawingCanvas {
        width: 100%;
        height: 400px;
        background: #121212;
        border-radius: 15px;
        cursor: none;
        position: relative;
      }

      .cursor {
        position: absolute;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: rgba(255, 126, 95, 0.8);
        pointer-events: none;
        transform: translate(-50%, -50%);
        z-index: 10;
        display: none;
      }

      .canvas-instructions {
        margin-top: 20px;
        text-align: center;
        color: #a0a0c0;
        font-size: 1.1rem;
      }

      .tools-panel {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 15px;
        margin-top: 20px;
      }

      .color-picker {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .color-label {
        color: #a0a0c0;
      }

      .brush-size {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .gesture-effect {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 10rem;
        z-index: 1000;
        pointer-events: none;
        opacity: 0;
        animation: gestureEffect 1.2s ease-out forwards;
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.7);
      }

      @keyframes gestureEffect {
        0% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(0.5);
        }
        50% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1.2);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(1.5);
        }
      }

      .instructions {
        background: rgba(25, 25, 35, 0.85);
        border-radius: 20px;
        padding: 25px;
        margin-top: 30px;
        width: 100%;
        max-width: 1000px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      }

      .instructions h2 {
        text-align: center;
        margin-bottom: 25px;
        color: #00f2fe;
        font-size: 2rem;
      }

      .gesture-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
      }

      .gesture-card {
        background: rgba(30, 30, 45, 0.7);
        border-radius: 15px;
        padding: 20px;
        text-align: center;
        transition: all 0.3s ease;
        border: 1px solid #4facfe;
      }

      .gesture-card:hover {
        transform: translateY(-10px);
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        background: rgba(40, 40, 60, 0.9);
      }

      .gesture-symbol {
        font-size: 4rem;
        margin-bottom: 15px;
        height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .gesture-card h3 {
        font-size: 1.4rem;
        color: #ff7e5f;
        margin-bottom: 10px;
      }

      .gesture-card p {
        color: #b0b0d0;
        font-size: 1.1rem;
      }

      footer {
        text-align: center;
        padding: 30px 0 20px;
        color: rgba(255, 255, 255, 0.6);
        font-size: 1rem;
        width: 100%;
        margin-top: 30px;
      }

      @media (max-width: 900px) {
        .container {
          flex-direction: column;
          align-items: center;
        }

        .canvas-container,
        .camera-container {
          min-width: 90%;
        }
      }

      @media (max-width: 600px) {
        .camera-view {
          height: 300px;
        }

        #drawingCanvas {
          height: 350px;
        }

        .gesture-symbol {
          font-size: 3rem;
          height: 60px;
        }

        .gesture-card h3 {
          font-size: 1.2rem;
        }

        .control-btn {
          padding: 12px 20px;
          font-size: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>é«˜çº§æ‰‹åŠ¿ç»˜ç”»æ¿</h1>
      <p class="subtitle">æµç•…è½¨è¿¹ä¼˜åŒ–ç‰ˆ - è§£å†³æŠ–åŠ¨ä¸å»¶è¿Ÿé—®é¢˜</p>
    </header>

    <div class="container">
      <div class="camera-container">
        <div class="camera-header">
          <h2>æ‰‹åŠ¿è¯†åˆ«æ§åˆ¶å°</h2>
          <p>å¯ç”¨æ‘„åƒå¤´å¼€å§‹æ‰‹åŠ¿æ§åˆ¶</p>
        </div>

        <div class="camera-view">
          <video id="webcam" autoplay playsinline></video>
          <div id="cameraPlaceholder">
            <i class="material-icons" style="font-size: 4rem; color: #4facfe"
              >videocam_off</i
            >
            <p style="margin-top: 15px; color: #a0a0c0">æ‘„åƒå¤´æœªå¯ç”¨</p>
          </div>
        </div>

        <div id="gesture_output" class="gesture-output">
          <div class="gesture-name">ç­‰å¾…æ‰‹åŠ¿è¯†åˆ«</div>
          <div class="gesture-desc">è¯·å¯ç”¨æ‘„åƒå¤´å¹¶åšå‡ºæ‰‹åŠ¿</div>
        </div>

        <div class="controls">
          <button id="webcamButton" class="control-btn">
            <i class="material-icons">videocam</i> å¯ç”¨æ‘„åƒå¤´
          </button>
          <button id="clearCanvasBtn" class="control-btn">
            <i class="material-icons">clear</i> æ¸…é™¤ç”»å¸ƒ
          </button>
          <button id="undoBtn" class="control-btn">
            <i class="material-icons">undo</i> æ’¤é”€ä¸€æ­¥
          </button>
          <div class="mode-indicator">
            <i class="material-icons">edit</i>
            <span id="modeText">è‡ªç”±ç»˜åˆ¶æ¨¡å¼</span>
          </div>
        </div>
      </div>

      <div class="canvas-container">
        <div class="canvas-header">
          <h2>æ‰‹åŠ¿ç»˜ç”»åŒºåŸŸ</h2>
          <p>ä½¿ç”¨é£ŸæŒ‡åœ¨ç©ºä¸­ç»˜ç”»ï¼Œè½¨è¿¹å°†æ˜¾ç¤ºåœ¨ç”»å¸ƒä¸Š</p>
        </div>

        <canvas id="drawingCanvas"></canvas>
        <div id="cursor" class="cursor"></div>

        <div class="tools-panel">
          <div class="color-picker">
            <span class="color-label">ç”»ç¬”é¢œè‰²:</span>
            <input type="color" id="colorPicker" value="#ff7e5f" />
          </div>

          <div class="brush-size">
            <span class="color-label">ç”»ç¬”å¤§å°:</span>
            <input type="range" id="brushSize" min="1" max="20" value="5" />
            <span id="brushSizeValue">5px</span>
          </div>
        </div>

        <div class="canvas-instructions">
          <p>æ‰‹åŠ¿è¯´æ˜ï¼š</p>
          <p>
            ğŸ‘† é£ŸæŒ‡å‘ä¸‹ï¼šç»˜ç”» | âœ‹ æ‰‹æŒå¼ å¼€ï¼šæ¸…é™¤ç”»å¸ƒ | âœŒï¸ èƒœåˆ©æ‰‹åŠ¿ï¼šç›´çº¿æ¨¡å¼ |
            ğŸ‘ ç‚¹èµæ‰‹åŠ¿ï¼šæ’¤é”€
          </p>
        </div>
      </div>
    </div>

    <div class="instructions">
      <h2>ä¼˜åŒ–æ–¹æ¡ˆè¯´æ˜</h2>
      <div class="gesture-grid">
        <div class="gesture-card">
          <div class="gesture-symbol">ğŸ“‰</div>
          <h3>è½¨è¿¹æŠ–åŠ¨ä¼˜åŒ–</h3>
          <p>ä½¿ç”¨ç§»åŠ¨å¹³å‡ç®—æ³•å¹³æ»‘è½¨è¿¹</p>
          <p><small>å‡å°‘æ‰‹æŒ‡æŠ–åŠ¨å½±å“</small></p>
        </div>

        <div class="gesture-card">
          <div class="gesture-symbol">âš¡</div>
          <h3>å»¶è¿Ÿä¼˜åŒ–</h3>
          <p>ä¼˜åŒ–ç»˜åˆ¶é€»è¾‘ä¸è¯†åˆ«é¢‘ç‡</p>
          <p><small>ä½¿ç”¨è·¯å¾„ç»˜åˆ¶è€Œéçº¿æ®µ</small></p>
        </div>

        <div class="gesture-card">
          <div class="gesture-symbol">ğŸ“</div>
          <h3>ç›´çº¿æ¨¡å¼</h3>
          <p>Victoryæ‰‹åŠ¿è¿›å…¥ç›´çº¿ç»˜åˆ¶</p>
          <p><small>ä¸¤ç‚¹ç¡®å®šä¸€æ¡ç›´çº¿</small></p>
        </div>

        <div class="gesture-card">
          <div class="gesture-symbol">â†©ï¸</div>
          <h3>æ’¤é”€åŠŸèƒ½</h3>
          <p>ç‚¹èµæ‰‹åŠ¿æ’¤é”€ä¸Šä¸€æ­¥æ“ä½œ</p>
          <p><small>æ”¯æŒå¤šçº§æ’¤é”€</small></p>
        </div>
      </div>
    </div>

    <footer>
      <p>é«˜çº§æ‰‹åŠ¿ç»˜ç”»æ¿ | è§£å†³æŠ–åŠ¨ä¸å»¶è¿Ÿé—®é¢˜ | åŸºäºMediaPipeæ‰‹åŠ¿è¯†åˆ«æŠ€æœ¯</p>
    </footer>

    <script type="module">
      // å¼•å…¥MediaPipeæ‰‹åŠ¿è¯†åˆ«åº“
      import {
        GestureRecognizer,
        FilesetResolver,
      } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

      // DOMå…ƒç´ å¼•ç”¨
      const gestureOutput = document.getElementById("gesture_output");
      const webcamButton = document.getElementById("webcamButton");
      const videoElement = document.getElementById("webcam");
      const cameraPlaceholder = document.getElementById("cameraPlaceholder");
      const clearCanvasBtn = document.getElementById("clearCanvasBtn");
      const undoBtn = document.getElementById("undoBtn");
      const brushSize = document.getElementById("brushSize");
      const brushSizeValue = document.getElementById("brushSizeValue");
      const colorPicker = document.getElementById("colorPicker");
      const modeText = document.getElementById("modeText");
      const cursor = document.getElementById("cursor");

      // è·å–ç”»å¸ƒå’Œä¸Šä¸‹æ–‡
      const canvas = document.getElementById("drawingCanvas");
      const ctx = canvas.getContext("2d");

      // å…¨å±€å˜é‡
      let gestureRecognizer;
      let webcamRunning = false;
      let lastGesture = "";
      let lastDetectionTime = 0;
      let isDrawing = false;
      let brushColor = "#ff7e5f";
      let brushWidth = 5;
      let isStraightLineMode = false;
      let straightLineStart = null;
      let lastPoints = []; // ç”¨äºè½¨è¿¹å¹³æ»‘
      let drawHistory = []; // ç”¨äºæ’¤é”€åŠŸèƒ½
      let currentPath = null; // å½“å‰ç»˜åˆ¶è·¯å¾„

      // è®¾ç½®ç”»å¸ƒå°ºå¯¸
      function setupCanvas() {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        ctx.lineWidth = brushWidth;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = brushColor;

        // ä¿å­˜åˆå§‹çŠ¶æ€
        saveCanvasState();

        // ç»˜åˆ¶åˆå§‹è¯´æ˜
        ctx.font = "24px Roboto";
        ctx.fillStyle = "#a0a0c0";
        ctx.textAlign = "center";
        ctx.fillText(
          "è¯·å¯ç”¨æ‘„åƒå¤´å¹¶åšå‡ºğŸ‘†æ‰‹åŠ¿å¼€å§‹ç»˜ç”»",
          canvas.width / 2,
          canvas.height / 2
        );
      }

      // åˆå§‹åŒ–ç”»å¸ƒ
      setupCanvas();
      window.addEventListener("resize", setupCanvas);

      // ä¿å­˜ç”»å¸ƒçŠ¶æ€ï¼ˆç”¨äºæ’¤é”€ï¼‰
      function saveCanvasState() {
        drawHistory.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        // é™åˆ¶å†å²è®°å½•æ•°é‡
        if (drawHistory.length > 20) {
          drawHistory.shift();
        }
      }

      // æ’¤é”€ä¸Šä¸€æ­¥æ“ä½œ
      function undo() {
        if (drawHistory.length > 1) {
          drawHistory.pop(); // ç§»é™¤å½“å‰çŠ¶æ€
          const prevState = drawHistory[drawHistory.length - 1];
          ctx.putImageData(prevState, 0, 0);
          showGestureEffect("â†©ï¸");
        }
      }

      // æ¸…é™¤ç”»å¸ƒ
      function clearCanvas() {
        drawHistory = [];
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        setupCanvas();
        showGestureEffect("âœ‹");
      }

      // åˆ›å»ºæ‰‹åŠ¿è¯†åˆ«å™¨
      async function createGestureRecognizer() {
        try {
          const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
          );

          gestureRecognizer = await GestureRecognizer.createFromOptions(
            vision,
            {
              baseOptions: {
                modelAssetPath:
                  "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                delegate: "GPU",
              },
              runningMode: "VIDEO",
              numHands: 1,
            }
          );

          console.log("æ‰‹åŠ¿è¯†åˆ«å™¨å·²åŠ è½½");
          gestureOutput.innerHTML = `
                    <div class="gesture-name">è¯†åˆ«å™¨å·²å°±ç»ª</div>
                    <div class="gesture-desc">è¯·å¯ç”¨æ‘„åƒå¤´å¼€å§‹æ‰‹åŠ¿æ§åˆ¶</div>
                `;

          webcamButton.disabled = false;
          clearCanvasBtn.disabled = false;
          undoBtn.disabled = false;
        } catch (error) {
          console.error("æ‰‹åŠ¿è¯†åˆ«å™¨åˆ›å»ºå¤±è´¥:", error);
          gestureOutput.innerHTML = `
                    <div class="gesture-name">è¯†åˆ«å™¨åŠ è½½å¤±è´¥</div>
                    <div class="gesture-desc">è¯·åˆ·æ–°é¡µé¢é‡è¯•</div>
                `;
        }
      }

      // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒæ‘„åƒå¤´
      function hasGetUserMedia() {
        return !!(
          navigator.mediaDevices && navigator.mediaDevices.getUserMedia
        );
      }

      // æ·»åŠ æ‘„åƒå¤´å¯ç”¨æŒ‰é’®äº‹ä»¶
      if (hasGetUserMedia()) {
        webcamButton.addEventListener("click", toggleWebcam);
        clearCanvasBtn.addEventListener("click", clearCanvas);
        undoBtn.addEventListener("click", undo);
      } else {
        console.warn("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®");
        webcamButton.disabled = true;
        webcamButton.innerHTML =
          '<i class="material-icons">warning</i> æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´';
      }

      // ç”»ç¬”å¤§å°è°ƒæ•´
      brushSize.addEventListener("input", () => {
        brushWidth = brushSize.value;
        brushSizeValue.textContent = brushWidth + "px";
        ctx.lineWidth = brushWidth;
      });

      // é¢œè‰²é€‰æ‹©å™¨
      colorPicker.addEventListener("input", () => {
        brushColor = colorPicker.value;
        ctx.strokeStyle = brushColor;
      });

      // åˆ‡æ¢æ‘„åƒå¤´çŠ¶æ€
      async function toggleWebcam() {
        if (!gestureRecognizer) {
          alert("æ‰‹åŠ¿è¯†åˆ«å™¨å°šæœªåŠ è½½å®Œæˆï¼Œè¯·ç¨å€™");
          return;
        }

        if (webcamRunning) {
          // å…³é—­æ‘„åƒå¤´
          stopWebcam();
          webcamButton.innerHTML =
            '<i class="material-icons">videocam</i> å¯ç”¨æ‘„åƒå¤´';
          cursor.style.display = "none";
        } else {
          // å¯ç”¨æ‘„åƒå¤´
          try {
            webcamButton.innerHTML =
              '<i class="material-icons">hourglass_top</i> æ­£åœ¨å¯åŠ¨...';
            await startWebcam();
            webcamButton.innerHTML =
              '<i class="material-icons">videocam_off</i> å…³é—­æ‘„åƒå¤´';
            cursor.style.display = "block";
          } catch (error) {
            console.error("æ‘„åƒå¤´å¯ç”¨å¤±è´¥:", error);
            webcamButton.innerHTML =
              '<i class="material-icons">videocam</i> å¯ç”¨æ‘„åƒå¤´';
          }
        }
      }

      // å¯åŠ¨æ‘„åƒå¤´
      async function startWebcam() {
        try {
          // è¯·æ±‚æ‘„åƒå¤´è®¿é—®æƒé™
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: "user",
              width: { ideal: 640 },
              height: { ideal: 480 },
              frameRate: { ideal: 30 },
            },
          });

          videoElement.srcObject = stream;
          cameraPlaceholder.style.display = "none";

          // ç­‰å¾…è§†é¢‘æ•°æ®åŠ è½½
          await new Promise((resolve) => {
            videoElement.onloadeddata = resolve;
          });

          // å¼€å§‹é¢„æµ‹
          webcamRunning = true;
          lastDetectionTime = performance.now();
          predictWebcam();
        } catch (err) {
          console.error("æ‘„åƒå¤´è®¿é—®é”™è¯¯:", err);
          if (err.name === "NotAllowedError") {
            alert("æ‘„åƒå¤´è®¿é—®è¢«æ‹’ç»ã€‚è¯·æ£€æŸ¥æµè§ˆå™¨æƒé™è®¾ç½®å¹¶å…è®¸è®¿é—®æ‘„åƒå¤´ã€‚");
          } else {
            alert(`æ— æ³•è®¿é—®æ‘„åƒå¤´: ${err.message}`);
          }
          throw err;
        }
      }

      // åœæ­¢æ‘„åƒå¤´
      function stopWebcam() {
        webcamRunning = false;
        if (videoElement.srcObject) {
          const tracks = videoElement.srcObject.getTracks();
          tracks.forEach((track) => track.stop());
          videoElement.srcObject = null;
        }

        cameraPlaceholder.style.display = "flex";
        gestureOutput.innerHTML = `
                <div class="gesture-name">æ‘„åƒå¤´å·²å…³é—­</div>
                <div class="gesture-desc">ç‚¹å‡»æŒ‰é’®é‡æ–°å¯ç”¨</div>
            `;

        // é‡ç½®ç»˜ç”»çŠ¶æ€
        isDrawing = false;
        isStraightLineMode = false;
      }

      // è½¨è¿¹å¹³æ»‘å¤„ç†ï¼ˆç§»åŠ¨å¹³å‡ï¼‰
      function smoothPoint(newX, newY) {
        // æ·»åŠ æ–°ç‚¹
        lastPoints.push({ x: newX, y: newY });

        // é™åˆ¶å†å²ç‚¹æ•°é‡ï¼ˆ5ä¸ªç‚¹ï¼‰
        if (lastPoints.length > 5) {
          lastPoints.shift();
        }

        // è®¡ç®—å¹³å‡å€¼
        let avgX = 0,
          avgY = 0;
        for (const point of lastPoints) {
          avgX += point.x;
          avgY += point.y;
        }
        avgX /= lastPoints.length;
        avgY /= lastPoints.length;

        return { x: avgX, y: avgY };
      }

      // é¢„æµ‹æ‘„åƒå¤´ç”»é¢
      async function predictWebcam() {
        if (!webcamRunning) return;

        // é™åˆ¶æ£€æµ‹é¢‘ç‡ï¼ˆæ¯100msæ£€æµ‹ä¸€æ¬¡ï¼‰
        const now = performance.now();
        if (now - lastDetectionTime < 100) {
          requestAnimationFrame(predictWebcam);
          return;
        }
        lastDetectionTime = now;

        // å¼€å§‹æ£€æµ‹
        try {
          // æ£€æµ‹æ‰‹åŠ¿
          const results = await gestureRecognizer.recognizeForVideo(
            videoElement,
            Date.now()
          );

          // æ˜¾ç¤ºæ‰‹åŠ¿è¯†åˆ«ç»“æœå¹¶å¤„ç†äº¤äº’
          if (results.gestures.length > 0) {
            const categoryName = results.gestures[0][0].categoryName;
            const categoryScore = parseFloat(
              results.gestures[0][0].score * 100
            ).toFixed(2);

            gestureOutput.innerHTML = `
                        <div class="gesture-name">${categoryName}</div>
                        <div class="gesture-desc">ç½®ä¿¡åº¦: ${categoryScore}%</div>
                    `;

            // å¤„ç†æ‰‹åŠ¿äº¤äº’
            if (lastGesture !== categoryName) {
              handleGestureInteraction(categoryName);
              lastGesture = categoryName;
            }

            // å¤„ç†ç»˜ç”»é€»è¾‘
            if (results.landmarks && results.landmarks.length > 0) {
              const landmarks = results.landmarks[0];
              if (landmarks.length >= 9) {
                // ç¡®ä¿æœ‰è¶³å¤Ÿçš„å…³èŠ‚ç‚¹
                const indexFingerTip = landmarks[8]; // é£ŸæŒ‡æŒ‡å°–

                // å…³é”®ä¿®å¤ï¼šé•œåƒç¿»è½¬åæ ‡ç‚¹
                const rawX = canvas.width - indexFingerTip.x * canvas.width;
                const rawY = indexFingerTip.y * canvas.height;

                // è½¨è¿¹å¹³æ»‘å¤„ç†
                const { x, y } = smoothPoint(rawX, rawY);

                // æ›´æ–°å…‰æ ‡ä½ç½®
                cursor.style.left = `${x}px`;
                cursor.style.top = `${y}px`;

                if (
                  categoryName === "Pointing_Up" ||
                  categoryName === "Victory"
                ) {
                  // å¼€å§‹æˆ–ç»§ç»­ç»˜ç”»
                  if (!isDrawing) {
                    isDrawing = true;
                    currentPath = [];
                    saveCanvasState();
                  }

                  // å¤„ç†ä¸åŒç»˜åˆ¶æ¨¡å¼
                  if (isStraightLineMode) {
                    // ç›´çº¿æ¨¡å¼
                    if (!straightLineStart) {
                      straightLineStart = { x, y };
                    }

                    // æ¸…é™¤å½“å‰ç”»å¸ƒåˆ°å†å²çŠ¶æ€
                    ctx.putImageData(drawHistory[drawHistory.length - 1], 0, 0);

                    // ç»˜åˆ¶èµ·ç‚¹åˆ°å½“å‰ç‚¹çš„ç›´çº¿
                    ctx.beginPath();
                    ctx.moveTo(straightLineStart.x, straightLineStart.y);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                  } else {
                    // è‡ªç”±ç»˜åˆ¶æ¨¡å¼
                    currentPath.push({ x, y });

                    // ä½¿ç”¨è·¯å¾„ç»˜åˆ¶æé«˜æ€§èƒ½
                    if (currentPath.length > 1) {
                      ctx.putImageData(
                        drawHistory[drawHistory.length - 1],
                        0,
                        0
                      );
                      ctx.beginPath();
                      ctx.moveTo(currentPath[0].x, currentPath[0].y);

                      // ç»˜åˆ¶è´å¡å°”æ›²çº¿ä½¿çº¿æ¡æ›´å¹³æ»‘
                      for (let i = 1; i < currentPath.length - 2; i++) {
                        const p1 = currentPath[i];
                        const p2 = currentPath[i + 1];
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        ctx.quadraticCurveTo(p1.x, p1.y, midX, midY);
                      }

                      // ç»˜åˆ¶æœ€åä¸€æ®µ
                      if (currentPath.length >= 2) {
                        const last = currentPath.length - 1;
                        const p1 = currentPath[last - 1];
                        const p2 = currentPath[last];
                        ctx.lineTo(p2.x, p2.y);
                      }

                      ctx.stroke();
                    }
                  }
                } else {
                  // å…¶ä»–æ‰‹åŠ¿åœæ­¢ç»˜ç”»
                  if (isDrawing) {
                    isDrawing = false;
                    straightLineStart = null;

                    // ä¿å­˜æœ€ç»ˆè·¯å¾„
                    if (currentPath.length > 0) {
                      saveCanvasState();
                      currentPath = null;
                    }
                  }
                }
              }
            }
          } else {
            gestureOutput.innerHTML = `
                        <div class="gesture-name">æœªæ£€æµ‹åˆ°æ‰‹åŠ¿</div>
                        <div class="gesture-desc">è¯·å°†æ‰‹æ”¾åœ¨æ‘„åƒå¤´å‰</div>
                    `;
            lastGesture = "";
            isDrawing = false;
            straightLineStart = null;
          }
        } catch (error) {
          console.error("æ‰‹åŠ¿è¯†åˆ«é”™è¯¯:", error);
          gestureOutput.innerHTML = `
                    <div class="gesture-name">è¯†åˆ«å‡ºé”™</div>
                    <div class="gesture-desc">è¯·é‡è¯•</div>
                `;
          isDrawing = false;
          straightLineStart = null;
        }

        // ç»§ç»­å¤„ç†
        requestAnimationFrame(predictWebcam);
      }

      // å¤„ç†æ‰‹åŠ¿äº¤äº’
      function handleGestureInteraction(gesture) {
        switch (gesture) {
          case "Open_Palm": // æ‰‹æŒå¼ å¼€ - æ¸…é™¤ç”»å¸ƒ
            clearCanvas();
            showGestureEffect("âœ‹");
            break;
          case "Pointing_Up": // é£ŸæŒ‡å‘ä¸‹ - å¼€å§‹ç»˜ç”»
            isStraightLineMode = false;
            modeText.textContent = "è‡ªç”±ç»˜åˆ¶æ¨¡å¼";
            showGestureEffect("ğŸ‘†");
            break;
          case "Victory": // èƒœåˆ©æ‰‹åŠ¿ - ç›´çº¿æ¨¡å¼
            isStraightLineMode = true;
            modeText.textContent = "ç›´çº¿ç»˜åˆ¶æ¨¡å¼";
            showGestureEffect("âœŒï¸");
            break;
          case "Thumb_Up": // ç‚¹èµæ‰‹åŠ¿ - æ’¤é”€
            undo();
            break;
          case "Thumb_Down": // ç‚¹è¸©æ‰‹åŠ¿ - éšæœºé¢œè‰²
            brushColor = getRandomColor();
            ctx.strokeStyle = brushColor;
            colorPicker.value = brushColor;
            showGestureEffect("ğŸ‘");
            break;
          default:
            // å…¶ä»–æœªå®šä¹‰æ‰‹åŠ¿ä¸å¤„ç†
            break;
        }
      }

      // è·å–éšæœºé¢œè‰²
      function getRandomColor() {
        const letters = "0123456789ABCDEF";
        let color = "#";
        for (let i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      }

      // æ˜¾ç¤ºæ‰‹åŠ¿æ•ˆæœ
      function showGestureEffect(symbol) {
        const effect = document.createElement("div");
        effect.className = "gesture-effect";
        effect.textContent = symbol;
        document.body.appendChild(effect);

        // åŠ¨ç”»ç»“æŸåç§»é™¤å…ƒç´ 
        setTimeout(() => {
          effect.remove();
        }, 1200);
      }

      // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«å™¨
      createGestureRecognizer();
    </script>
  </body>
</html>
